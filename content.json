{"pages":[],"posts":[{"title":"JS中的BOM","text":"","link":"/articles/2022/05/26/js-JS%E4%B8%AD%E7%9A%84BOM/"},{"title":"数据类型","text":"ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和 Symbol，还有一种复杂数据类型叫 Object（对象），其中Symbol是ES6新增 基本类型 boolean null undefined number string symbol 内存中：只占用了栈，没有使用堆；值就是地址，地址就是值；复制时，直接复制值 复杂类型在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。 当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。 object function Array 内存中：既使用了栈，又使用了堆；栈中存放了一个堆地址；堆地址指向了一个堆空间，内存储了实际数据 根据地址找到数值；复制时，复制的是地址，没有复制值 判断数据类型判断数据类型有typeof和instanceof typeoftypeof 对于简单类型来说，除了 null 都可以显示正确的类型 12345typeof 1 // 'number'typeof '1' // 'string'typeof undefined // 'undefined'typeof true // 'boolean'typeof Symbol() // 'symbol' typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型 123typeof [] // 'object'typeof {} // 'object'typeof console.log // 'function' instanceof判断一个对象的正确类型，这时候可以考虑使用 instanceof，内部机制是通过原型链来判断的 123456789const Person = function() {}const p1 = new Person()p1 instanceof Person // truevar str = 'hello world'str instanceof String // falsevar str1 = new String('hello world')str1 instanceof String // true 对于原始数据类型直接使用instanceof是不行的，可以使用以下方法判断 123456class PrimitiveData { static [Symbol.hasInstance](x) { return typeof x === 'string' }}console.log('hello world' instanceof PrimitiveData) // true 类型转换JS 中类型转换只有三种情况： 转换为布尔值 转换为数字 转换为字符串 类型转换表格 原始值 转换目标 结果 number 布尔值 除0、-0、NaN都为true String 布尔值 除空为true undefined、null 布尔值 false 引用类型 布尔值 true number 字符串 0 =&gt; ‘0’ Boolean、函数、Symbol 字符串 ‘true’ 数组 字符串 [1,2]=&gt; ‘1,2’ 对象 字符串 “[object Object]” String 数字 ‘1’=&gt;1、’a’ =&gt; NaN 数组 数字 空为0，存在一个值且为数字转数字，其他NaN null 数字 0 除了数组的引用类型 数字 NaN Symbol 数字 报错 换Boolean 在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象 对象转基本类型对象在转换类型的时候，会调用内置的函数方法： - 如果已经是基本类型了，那就不需要转换了 - 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回原始类型，就会报错 四则运算符加法运算符不同于其他几个运算符，它有以下几个特点： 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 对于除加法运算符以外只要其中一方是数字，那么另一方就会被转为数字 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 在对比是如果是对象，会通过valueOf 转换为原始类型再比较值。","link":"/articles/2022/05/26/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript","text":"JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。 ECMAScript：由 ECMA-262 定义并提供核心功能 文档对象模型（DOM）：提供与网页内容交互的方法和接口（API） 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口 Javascript资料地址 ECMAScript ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言 ECMA-262定义内容 语法 类型 语句 关键字 保留字 操作符 全局对象 DOM文档对象模型(document)是一个编程接口(API)。 DOM 通过创建表示文档的树，可以随心所欲地控制网页的内容和结构。 使用 DOM API，可以轻松地删除、添加、替换、修改节点 BOM浏览器对象模型，用于支持访问和操作浏览器的窗口，可以操作浏览器显示页面以外的部分 BOM操作内容的范畴 弹出新浏览器窗口的能力 移动、缩放和关闭浏览器窗口的能力 navigator 对象，提供关于浏览器的详尽信息 location 对象，提供浏览器加载页面的详尽信息 screen 对象，提供关于用户屏幕分辨率的详尽信息 performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息 对 cookie 的支持","link":"/articles/2022/05/26/js-JavaScript/"},{"title":"关键字和保留字","text":"ECMA-262 描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，保留的关键字和保留字不能用作标识符或属性名 关键字和保留字详细 关键字123456789break do in typeof case else instanceof var catch export new void class extends return while const finally super with continue for switch yield debugger function this default if throw delete import try 保留字始终保留 1enum 严格模式下保留 123implements package public interface protected static let private 模块代码中的保留 1await","link":"/articles/2022/05/26/js-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97/"},{"title":"变量","text":"变量可以用于保存任何类型的数据，每个变量不过是用于保存任意值的命名站位符 声明变量： var 、const、let 。var在任何ES版本中都可以使用，const和let只能在ES6以上的版本中使用 var声明使用 var 操作符定义变量，并保存任何类型的值 123// 声明单个和声明多个var massage = 1;var age = 23,name = &quot;bole&quot; 1. 声明作用域​ 使用 var 操作符定义的变量会成为包含它的函数的局部变量，在全局声明回成为全局变量 2. 声明提升​ var声明的变量回自动提升到函数作用域顶部 let声明let和var的用法和作用差不多，但let声明的范围是块级作用域，而var声明的范围是函数作用域 123// 声明单个和声明多个let massage = 1;let age = 23,name = &quot;bole&quot; 1. 暂时性死区let与 var的另一个重要的区别，就是 let声明的变量不会在作用域中被提升 12345console.log(name) // undefindvar name = &quot;mt&quot;console.log(age) // ReferenceError：age 未定义let age = 23 在 let 声明之前的执行瞬间被称为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。 全局声明​ let在全局作用域中声明的变量不会成为window对象的属性 const声明const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const声明的变量会导致运行时错误，也不允许重复声明，但可以改值 123// 声明单个和声明多个const massage = 1;const age = 23,name = &quot;bole&quot; 小结const，let，var的区别 let和var的区别 作用域不会提升 全局变量不会绑定到window上 不允许重复声明 具有块级作用域 暂时性死区，作用域前变更变量的值无法生效 const和let的区别 const具有let的特点，但const不允许修改声明的变量 const不允许修改变量，但可以改变量内的值（例如对象，数组等）","link":"/articles/2022/05/26/js-%E5%8F%98%E9%87%8F/"},{"title":"函数","text":"函数实际上是对象；每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。 函数表达式12345function functionName(arg0, arg1,...,argN) { ... }functionName(arg0, arg1,...,argN)let functionName = function (arg0, arg1,...,argN){ ... }functionName(arg0, arg1,...,argN) 箭头函数 语法简单 省略大括号会隐式返回 不能使用arguments，super，new.target 没有prototype 1let set = ()=&gt;{} return return 会停止代码执行，return语句后面的代码就不执行 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。 arguments arguments是一个类数组对象，包括调用函数是传入的所有参数 arguments中有一个callee属性，是指向arguments对象所在的函数指针 使用arguments.callee可以让函数逻辑和函数名解耦 123function factorial(num){if(num&lt;=1){return 1}else{return num*arguments.callee(num-1)}} 递归指在函数内部调用自己，达到条件停止 123456789function fib(){return fibImpl(0,1,n)}function fibImpl(a,b,n){if(n===0){return a}return fibImpl(b,a+b,n-1)} 闭包this标准函数中this引用的是吧函数当成方法调用的上下文对象；在全局调用指向的是windows；在箭头函数中，this引用的是定义箭头函数的上下文 常规函数中的this12345678910111213function foo() { console.log(this.a)}var a = 1foo()const obj = { a: 2, foo: foo}obj.foo()const c = new foo() 直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 箭头函数中的this箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。 12345678function a() { return () =&gt; { return () =&gt; { console.log(this) } }}console.log(a()()()) 在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。 apply，call，bind 共同点 函数的方法，改变函数的执行上下文 this 取决于第一个参数，如果第一个参数为空，那么就是 window。 对一个函数进行多次改变执行上下文，函数中的this永远由第一次 bind 决定 区别 call、apply 是立即执行的，bind 不会立即执行，会返回一个函数 apply 最多只能传两个参数（替换this 指向的对象, [...arr]）；call、bind可以传递多个参数（替换this 指向的对象, …arr） 实现call12345678910111213141516//挂载到函数的原型上Function.prototype.MyCall = function( ops ){ //判断第一个值有没有，没有将this绑定到window上 let cont = Object(ops) || window // 保存当前调用MyCall的函数 cont.fn = this let result = '' // 取出除第一个值的所有值 const val = [...arguments].slice(1) // 执行当前调用函数 result = cont.fn(...val) // 删除 delete cont.fn // 返回结果 return result } 实现bind1234567891011121314151617181920212223//挂载到函数的原型上Function.prototype.MyBind = function( ops ){ // 判断调用MyBind是不是一个函数 if(typeof this !== 'function'){ throw new Error('调用者不是一个函数！') } // 保存当前调用MyCall的函数 const self = this // 4. 获取调用该方法时传入的除改变this 指向的对象参数的剩余参数 const args1 = [...arguments].slice(1) // 5. 需要返回一个函数 const bindFn = function(){ // 这个函数相当于调用bind() 的函数，只是内部需要将this 指向content // 获取第二个参数，也就是bind之后返回的函数执行时传入的参数 const args2 = [...arguments] // 重要一步 当bind之后返回的函数执行时，相当于这个函数bindFn被执行，所以bindFn需要一个返回值 return self.apply(content, args1.concat(args2)) } return bindFn } 实现apply12345678910111213141516171819202122232425//挂载到函数的原型上Function.prototype.MyApply = function( ops ){ // 2. 判断传入的第一个参数存不存在，存在则转为object 对象，不存在则为window 对象 var context = Object(content) || window // 3. 在替换this 指向的对象上定义一个函数，值为this MyApply() 的函数方法 context.fn = this // 4. 定义保存返回值 let result = '' // 5. 判断第二个参数args 存不存在，不存在，返回执行之后的fn()结果，存在，展开参数返回执行之后的fn()结果 if(!args) { result = context.fn() } else { result = context.fn(...args) } // 7. 执行完之后删除fn delete context.fn // 8. 返回结果 return result } 相关链接 调用优先级new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。","link":"/articles/2022/05/30/js-%E5%87%BD%E6%95%B0/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"JS基础","slug":"JS基础","link":"/tags/JS%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript介绍","slug":"JavaScript介绍","link":"/tags/JavaScript%E4%BB%8B%E7%BB%8D/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","link":"/categories/JavaScript/%E5%9F%BA%E7%A1%80/"}]}