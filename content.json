{"pages":[],"posts":[{"title":"JS中的BOM","text":"BOM浏览器对象模型，BOM由多个对象组成，其中代表浏览器窗口的Window对象是BOM的顶层对象，其他对象都是该对象的子对象（Screen、Location、History、Navigator）。 window 对象中的属性 属性 描述 document 对 Document 对象的只读引用 history 对 History 对象的只读引用，该对象中包含了用户在浏览器中访问过的 URL innerHeight 返回浏览器窗口的高度，不包含工具栏与滚动条 innerWidth 返回浏览器窗口的宽度，不包含工具栏与滚动条 localStorage 在浏览器中以键值对的形式保存某些数据，保存的数据没有过期时间，会永久保存在浏览器中，直至手动删除 sessionStorage 在浏览器中以键值对的形式存储一些数据，数据会在关闭浏览器窗口或标签页之后删除 location 引用窗口或框架的 Location 对象，该对象中包含当前 URL 的有关信息 navigator 对 Navigator 对象的只读引用，该对象中包含当前浏览器的有关信息 opener 返回对创建此窗口的 window 对象的引用 outerHeight 返回浏览器窗口的完整高度，包含工具栏与滚动条 outerWidth 返回浏览器窗口的完整宽度，包含工具栏与滚动条 pageXOffset 设置或返回当前页面相对于浏览器窗口左上角沿水平方向滚动的距离 pageYOffset 设置或返回当前页面相对于浏览器窗口左上角沿垂直方向滚动的距离 defaultStatus 设置或返回窗口状态栏中的默认文本 closed 返回窗口是否已被关闭 frames 返回窗口中所有已经命名的框架集合，集合由 Window 对象组成，每个 Window 对象在窗口中含有一个 &lt;frame&gt; 或 &lt;iframe&gt; 标签 length 返回当前窗口中 &lt;iframe&gt; 框架的数量 parent 返回父窗口 name 设置或返回窗口的名称 screen 对 Screen 对象的只读引用，该对象中包含计算机屏幕的相关信息 screenLeft 返回浏览器窗口相对于计算机屏幕的 X 坐标 screenTop 返回浏览器窗口相对于计算机屏幕的 Y 坐标 screenX 返回浏览器窗口相对于计算机屏幕的 X 坐标 screenY 返回浏览器窗口相对于计算机屏幕的 Y 坐标 self 返回对 window 对象的引用 status 设置窗口状态栏的文本 top 返回最顶层的父窗口 示例代码： 1","link":"/articles/2022/05/26/js-JS%E4%B8%AD%E7%9A%84BOM/"},{"title":"数据类型","text":"ECMAScript 有 6 种简单数据类型（也称为原始类型）：Undefined、Null、Boolean、Number、String和 Symbol，还有一种复杂数据类型叫 Object（对象），其中Symbol是ES6新增 基本类型 boolean null undefined number string symbol 内存中：只占用了栈，没有使用堆；值就是地址，地址就是值；复制时，直接复制值 复杂类型在 JS 中，除了原始类型那么其他的都是对象类型了。对象类型和原始类型不同的是，原始类型存储的是值，对象类型存储的是地址（指针）。 当你创建了一个对象类型的时候，计算机会在内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。 object function Array 内存中：既使用了栈，又使用了堆；栈中存放了一个堆地址；堆地址指向了一个堆空间，内存储了实际数据 根据地址找到数值；复制时，复制的是地址，没有复制值 判断数据类型判断数据类型有typeof和instanceof typeoftypeof 对于简单类型来说，除了 null 都可以显示正确的类型 12345typeof 1 // 'number'typeof '1' // 'string'typeof undefined // 'undefined'typeof true // 'boolean'typeof Symbol() // 'symbol' typeof 对于对象来说，除了函数都会显示 object，所以说 typeof 并不能准确判断变量到底是什么类型 123typeof [] // 'object'typeof {} // 'object'typeof console.log // 'function' instanceof判断一个对象的正确类型，这时候可以考虑使用 instanceof，内部机制是通过原型链来判断的 123456789const Person = function() {}const p1 = new Person()p1 instanceof Person // truevar str = 'hello world'str instanceof String // falsevar str1 = new String('hello world')str1 instanceof String // true 对于原始数据类型直接使用instanceof是不行的，可以使用以下方法判断 123456class PrimitiveData { static [Symbol.hasInstance](x) { return typeof x === 'string' }}console.log('hello world' instanceof PrimitiveData) // true 类型转换JS 中类型转换只有三种情况： 转换为布尔值 转换为数字 转换为字符串 类型转换表格 原始值 转换目标 结果 number 布尔值 除0、-0、NaN都为true String 布尔值 除空为true undefined、null 布尔值 false 引用类型 布尔值 true number 字符串 0 =&gt; ‘0’ Boolean、函数、Symbol 字符串 ‘true’ 数组 字符串 [1,2]=&gt; ‘1,2’ 对象 字符串 “[object Object]” String 数字 ‘1’=&gt;1、’a’ =&gt; NaN 数组 数字 空为0，存在一个值且为数字转数字，其他NaN null 数字 0 除了数组的引用类型 数字 NaN Symbol 数字 报错 换Boolean 在条件判断时，除了 undefined， null， false， NaN， ''， 0， -0，其他所有值都转为 true，包括所有对象 对象转基本类型对象在转换类型的时候，会调用内置的函数方法： - 如果已经是基本类型了，那就不需要转换了 - 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值 调用 x.toString()，如果转换为基础类型，就返回转换的值 如果都没有返回原始类型，就会报错 四则运算符加法运算符不同于其他几个运算符，它有以下几个特点： 运算中其中一方为字符串，那么就会把另一方也转换为字符串 如果一方不是字符串或者数字，那么会将它转换为数字或者字符串 对于除加法运算符以外只要其中一方是数字，那么另一方就会被转为数字 比较运算符 如果是对象，就通过 toPrimitive 转换对象 如果是字符串，就通过 unicode 字符索引来比较 在对比是如果是对象，会通过valueOf 转换为原始类型再比较值。 逻辑运算符逻辑运算符包括全等===和等于== ===即比较类型也比较值 ==只比较值，如果两边的数据类型不一样，会进行类型转换，再进行大小的对比；详细转换可以参考类型转换表格","link":"/articles/2022/05/26/js-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"JavaScript","text":"JavaScript 是一门用来与网页交互的脚本语言，包含以下三个组成部分。 ECMAScript：由 ECMA-262 定义并提供核心功能 文档对象模型（DOM）：提供与网页内容交互的方法和接口（API） 浏览器对象模型（BOM）：提供与浏览器交互的方法和接口 Javascript资料地址 ECMAScript ECMAScript，即 ECMA-262 定义的语言，并不局限于 Web 浏览器。ECMA-262 将这门语言作为一个基准来定义，以便在它之上再构建更稳健的脚本语言 ECMA-262定义内容 语法 类型 语句 关键字 保留字 操作符 全局对象 DOM文档对象模型(document)是一个编程接口(API)。 DOM 通过创建表示文档的树，可以随心所欲地控制网页的内容和结构。 使用 DOM API，可以轻松地删除、添加、替换、修改节点 BOM浏览器对象模型，用于支持访问和操作浏览器的窗口，可以操作浏览器显示页面以外的部分 BOM操作内容的范畴 弹出新浏览器窗口的能力 移动、缩放和关闭浏览器窗口的能力 navigator 对象，提供关于浏览器的详尽信息 location 对象，提供浏览器加载页面的详尽信息 screen 对象，提供关于用户屏幕分辨率的详尽信息 performance 对象，提供浏览器内存占用、导航行为和时间统计的详尽信息 对 cookie 的支持","link":"/articles/2022/05/26/js-JavaScript/"},{"title":"关键字和保留字","text":"ECMA-262 描述了一组保留的关键字，这些关键字有特殊用途，比如表示控制语句的开始和结束，或者执行特定的操作。按照规定，保留的关键字和保留字不能用作标识符或属性名 关键字和保留字详细 关键字123456789break do in typeof case else instanceof var catch export new void class extends return while const finally super with continue for switch yield debugger function this default if throw delete import try 保留字始终保留 1enum 严格模式下保留 123implements package public interface protected static let private 模块代码中的保留 1await","link":"/articles/2022/05/26/js-%E5%85%B3%E9%94%AE%E5%AD%97%E5%92%8C%E4%BF%9D%E7%95%99%E5%AD%97/"},{"title":"变量","text":"变量可以用于保存任何类型的数据，每个变量不过是用于保存任意值的命名站位符 声明变量： var 、const、let 。var在任何ES版本中都可以使用，const和let只能在ES6以上的版本中使用 var声明使用 var 操作符定义变量，并保存任何类型的值 123// 声明单个和声明多个var massage = 1;var age = 23,name = &quot;bole&quot; 1. 声明作用域​ 使用 var 操作符定义的变量会成为包含它的函数的局部变量，在全局声明回成为全局变量 2. 声明提升​ var声明的变量回自动提升到函数作用域顶部 let声明let和var的用法和作用差不多，但let声明的范围是块级作用域，而var声明的范围是函数作用域 123// 声明单个和声明多个let massage = 1;let age = 23,name = &quot;bole&quot; 1. 暂时性死区let与 var的另一个重要的区别，就是 let声明的变量不会在作用域中被提升 12345console.log(name) // undefindvar name = &quot;mt&quot;console.log(age) // ReferenceError：age 未定义let age = 23 在 let 声明之前的执行瞬间被称为“暂时性死区”，在此阶段引用任何后面才声明的变量都会抛出 ReferenceError。 全局声明​ let在全局作用域中声明的变量不会成为window对象的属性 const声明const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const声明的变量会导致运行时错误，也不允许重复声明，但可以改值 123// 声明单个和声明多个const massage = 1;const age = 23,name = &quot;bole&quot; 小结const，let，var的区别 let和var的区别 作用域不会提升 全局变量不会绑定到window上 不允许重复声明 具有块级作用域 暂时性死区，作用域前变更变量的值无法生效 const和let的区别 const具有let的特点，但const不允许修改声明的变量 const不允许修改变量，但可以改变量内的值（例如对象，数组等）","link":"/articles/2022/05/26/js-%E5%8F%98%E9%87%8F/"},{"title":"函数","text":"函数实际上是对象；每个函数都是 Function类型的实例，而 Function也有属性和方法，跟其他引用类型一样。因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定。 函数表达式12345function functionName(arg0, arg1,...,argN) { ... }functionName(arg0, arg1,...,argN)let functionName = function (arg0, arg1,...,argN){ ... }functionName(arg0, arg1,...,argN) 箭头函数 语法简单 省略大括号会隐式返回 不能使用arguments，super，new.target 没有prototype 1let set = ()=&gt;{} return return 会停止代码执行，return语句后面的代码就不执行 最佳实践是函数要么返回值，要么不返回值。只在某个条件下返回值的函数会带来麻烦，尤其是调试时。 arguments arguments是一个类数组对象，包括调用函数是传入的所有参数 arguments中有一个callee属性，是指向arguments对象所在的函数指针 使用arguments.callee可以让函数逻辑和函数名解耦 123function factorial(num){if(num&lt;=1){return 1}else{return num*arguments.callee(num-1)}} 递归指在函数内部调用自己，达到条件停止 123456789function fib(){return fibImpl(0,1,n)}function fibImpl(a,b,n){if(n===0){return a}return fibImpl(b,a+b,n-1)} 闭包this标准函数中this引用的是吧函数当成方法调用的上下文对象；在全局调用指向的是windows；在箭头函数中，this引用的是定义箭头函数的上下文 常规函数中的this12345678910111213function foo() { console.log(this.a)}var a = 1foo()const obj = { a: 2, foo: foo}obj.foo()const c = new foo() 直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象 对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this 箭头函数中的this箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。 12345678function a() { return () =&gt; { return () =&gt; { console.log(this) } }}console.log(a()()()) 在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。 apply，call，bind 共同点 函数的方法，改变函数的执行上下文 this 取决于第一个参数，如果第一个参数为空，那么就是 window。 对一个函数进行多次改变执行上下文，函数中的this永远由第一次 bind 决定 区别 call、apply 是立即执行的，bind 不会立即执行，会返回一个函数 apply 最多只能传两个参数（替换this 指向的对象, [...arr]）；call、bind可以传递多个参数（替换this 指向的对象, …arr） 实现call12345678910111213141516//挂载到函数的原型上Function.prototype.MyCall = function( ops ){ //判断第一个值有没有，没有将this绑定到window上 let cont = Object(ops) || window // 保存当前调用MyCall的函数 cont.fn = this let result = '' // 取出除第一个值的所有值 const val = [...arguments].slice(1) // 执行当前调用函数 result = cont.fn(...val) // 删除 delete cont.fn // 返回结果 return result } 实现bind1234567891011121314151617181920212223//挂载到函数的原型上Function.prototype.MyBind = function( ops ){ // 判断调用MyBind是不是一个函数 if(typeof this !== 'function'){ throw new Error('调用者不是一个函数！') } // 保存当前调用MyCall的函数 const self = this // 4. 获取调用该方法时传入的除改变this 指向的对象参数的剩余参数 const args1 = [...arguments].slice(1) // 5. 需要返回一个函数 const bindFn = function(){ // 这个函数相当于调用bind() 的函数，只是内部需要将this 指向content // 获取第二个参数，也就是bind之后返回的函数执行时传入的参数 const args2 = [...arguments] // 重要一步 当bind之后返回的函数执行时，相当于这个函数bindFn被执行，所以bindFn需要一个返回值 return self.apply(content, args1.concat(args2)) } return bindFn } 实现apply12345678910111213141516171819202122232425//挂载到函数的原型上Function.prototype.MyApply = function( ops ){ // 2. 判断传入的第一个参数存不存在，存在则转为object 对象，不存在则为window 对象 var context = Object(content) || window // 3. 在替换this 指向的对象上定义一个函数，值为this MyApply() 的函数方法 context.fn = this // 4. 定义保存返回值 let result = '' // 5. 判断第二个参数args 存不存在，不存在，返回执行之后的fn()结果，存在，展开参数返回执行之后的fn()结果 if(!args) { result = context.fn() } else { result = context.fn(...args) } // 7. 执行完之后删除fn delete context.fn // 8. 返回结果 return result } 相关链接 调用优先级new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。","link":"/articles/2022/05/30/js-%E5%87%BD%E6%95%B0/"},{"title":"git使用","text":"Git运用和操作指令，git下载地址 操作指令查看git版本号 1git -v 初始化文件创建git隐藏文件： 1git init 配置用户信息 1234git config --global user.name &quot;全局用户名&quot;git config --global user.email &quot;全局邮箱&quot;git config user.name &quot;用户名&quot;git config user.email &quot;邮箱&quot; 添加到暂存区 1234// 添加某个文件git add ***.md // 添加目录的所有文件git add . 提交到版本库 12git commit -m &quot;提交信息&quot;git commit -m '忽略eslint报错提交' --no-verify 查看版本日志 1git log 查看操作日志 1git reflog 查看当前状态 1git status 查看文件的不同 1git diff 回退版本 1git reset --hard 版本号 本地和远程仓库建立链接 1git remote add 别名 远程仓库地址 查看删除现有链接 12git remote -vgit remote rm 别名 推送到远程仓库 1git push -u origin master 远程仓库克隆到本地 1git clone 远程仓库地址 分支操作 12345678// 查看分支git branch// 创建分支git branch b1// 删除本地分支git breanch -d b1// 选择分支git checkout b1 合并分支 先切换到合并到分支 1git merge b1 详细git操作","link":"/articles/2022/05/31/git/"},{"title":"原型","text":"原型链就是多个对象通过__proto__ 的方式连接了起来 Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 函数的 prototype 是一个对象 对象的 __proto__ 属性指向原型， __proto__ 将对象和原型连接起来组成了原型链 对于 obj 来说，可以通过 __proto__ 找到一个原型对象，在该对象中定义了很多函数让我们来使用 原型的 constructor 属性指向构造函数，构造函数又通过 prototype 属性指回原型","link":"/articles/2022/05/31/%E5%8E%9F%E5%9E%8B/"},{"title":"深浅拷贝","text":"对象类型在赋值的过程中其实是复制了地址，从而会导致改变了一方其他也都被改变的情况，可以使用深浅拷贝来解决这个问题 \u0010\u0010\u0010\u0010例如 ： 123456let a = { age: 1}let b = aa.age = 2console.log(b.age) // 2 \u0010\u0010\u0010\u0010 浅拷贝可以了利用Object.assign来解决问题；Object.assign 只会拷贝所有的属性值到新的对象中，如果属性值是对象的话，拷贝的是地址，所以并不是深拷贝 123456let a = { age: 1}let b = Object.assign({}, a)a.age = 2console.log(b.age) // 1 也可以使用...展开运算符来解决问题 123456let a = { age: 1}let b = { ...a }a.age = 2console.log(b.age) // 1 浅拷贝只解决了第一层的问题，如果接下去的值中还有对象的话，两者还是享有相同的地址，要解决这个问题就得使用深拷贝 深拷贝通常解决深拷贝可以使用JSON.parse(JSON.stringify(object))来解决 但这个方法存在局限性，会忽略 undefined，symbol、不能序列化函数、不能解决循环引用的对象（会报错），这个方法大部分场景可以使用 如果你所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel 12345678910111213141516171819202122232425// 简易实现深拷贝function structuralClone(obj) { return new Promise(resolve =&gt; { const { port1, port2 } = new MessageChannel() port2.onmessage = ev =&gt; resolve(ev.data) port1.postMessage(obj) })}var obj = { a: 1, b: { c: 2 }}obj.b.d = obj.b// 注意该方法是异步的// 可以处理 undefined 和循环引用对象const test = async () =&gt; { const clone = await structuralClone(obj) console.log(clone)}test() 推荐可以使用 lodash 的深拷贝函数","link":"/articles/2022/05/31/%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"},{"title":"闭包","text":"闭包的定义：函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。 123456789function A() { let a = 1 window.B = function () { console.log(a) }}A()B() // 1 JS中，闭包存在的意义就是让我们间接访问函数内部的变量 解决var定义的函数问题 使用闭包解决问题 1234567for (var i = 1; i &lt;= 5; i++) { ;(function (j) { setTimeout(function timer() { console.log(j) }, j * 1000) })(i)} 上面代码中，先使用了立即执行函数将 i 传入匿名函数内部，这个时候参数就被固定到j上不会改变，当下次执行timer时，就可以使用外部函数变量j，从而输出每一个i的值 使用setTimeout的第三个参数，这个参数会被当成 timer 函数的参数传入 123456789for (var i = 1; i &lt;= 5; i++) { setTimeout( function timer(j) { console.log(j) }, i * 1000, i )} 使用let来定义i，利用let自带作用域 12345for (let i = 1; i &lt;= 5; i++) { setTimeout(function timer() { console.log(i) }, i * 1000)}","link":"/articles/2022/05/31/%E9%97%AD%E5%8C%85/"},{"title":"数组方法","text":"数组的操作方法 迭代数组forEach遍历数组的方法，同for循环相同，无返回值，改变原数组 12Array.forEach((item, index) =&gt; {...}) map创建一个新数组，其返回值是该数组中的每个元素都传入提供函数执行后返回的结果，并将返回的结果组成新数组，提供函数必须包含返回值，不会改变原数组 123let newArr = Array.map((item, index, array) =&gt; { return item * 2}) 数组判断every判断数组中的值是否全部符合条件 判断数组中所有元素是否通过提供函数内的判断条件，全部通过为true，一项不通过返回false，不会改变原数组 123let inter = Array.every((item, index, array) =&gt; { return item &gt; 2}) some判断数组内是否包含某个值 判断数组中是否至少有一个元素通过提供函数内的判断条件，符号为true，不符合返回false,不会改变原数组 123let inter = Array.some((item, index, array) =&gt; { return item &gt; 2}) filter在数组中查找符合条件的值，过滤数组 返回一个包含符合条件元素的新数组，无符合条件返回空数组，不会改变原数组 查找indexOf从开头向后查找数组中的元素，存在返回对应的索引，不存在返回-1，判断是严格相等 1let index = indexOf(val, fromIndex) lastIndexOf从末尾向后查找数组中的元素，存在返回对应的索引，不存在返回-1，判断是严格相等 1let index = lastIndexOf(val, fromIndex) 操作队列 都会改变数组，并更改数组长度 push将一个或多个元素添加到数组的末尾，并返回该数组的新长度 1let num = push('val', 'ops') unshift将一个或多个元素添加到数组的开头，并返回该数组的新长度 1let num = unshift('val', 'ops') shift从数组中删除第一个元素，并返回该元素的值 1let item = Array.shift() pop从数组中删除最后一个元素，并返回该元素的值 1let item = Array.shift() 操作数组concat合并两个或多个数组 创建当前数组的副本，并将参数添加到副本数组尾部，返回副本，不会改变原数组，返回一个新数组 123var arr1 = ['a', 'b', 'c'];var arr2 = ['d', 'e', 'f'];console.log(arr1.concat(arr2));// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;] slice剥离副本，截取开始到结束之间的元素组成新数组 12345var colors = [&quot;red&quot;, &quot;green&quot;, &quot;blue&quot;, &quot;yellow&quot;, &quot;purple&quot;];var colors2 = colors.slice(1);var colors3 = colors.slice(1, 4);alert(colors2); // green,blue,yellow,purplealert(colors3); // green,blue,yellow splice从数组中删除任意个（可以是负的即增加）元素。 返回结果为被删除元素组成的新数组。 该方法会改变原数组，会将指定元素从原数组中删除； 1234let newArr = Array.splice(start, deleteCount, item1, item2, ...)//start参数1：起始索引index, //deleteCount参数2：需要删除的个数, //item1item2，参数3+：新的元素1, 新的元素2... 第三个及之后的参数是需要增加的元素。插入从起始索引的前一个位置开始。 可以理解成：删除了哪些元素，就在所在位置补充新的内容。 示例： 12345678var arr1 = ['a', 'b', 'c', 'd', 'e', 'f'];arr1.splice(1); //从第index为1的位置开始，删除元素arr2.splice(-2); //删除最后两个元素，和slice同样的思想。arr3.splice(1, 3); //从第index为1的位置开始删除元素,一共删除三个元素// 增加系列arr4.splice(1, 0, 'g', 'h') //纯增加情况//变更的情况就是 先删除再增加，即替换arr4.splice(1, 3, 'js', 'vue');//删除+增加 == 更改 补充 字符串转数组 123456//split方法let arr = str.split('需要分割的字符串')// 展开符let arr = [...'str']// fromlet arr = Array.from(&quot;abc&quot;) 转换数组toLocaleString返回一个字符串表示数组中的元素 toString返回逗号分隔的字符串形式拼接 1Array.toString() valueOf返回一个新的 Array Iterator 对象，该对象包含数组每个索引的值 123456const array1 = ['a', 'b', 'c'];const iterator = array1.values();for (const value of iterator) { console.log(value); // expected output: &quot;a&quot; &quot;b&quot; &quot;c&quot;} join改变分隔符，返回字符串，将数组转为以传入进来的字符串链接的字符串，默认是逗号 1Array.join('-') 排序sort对数组元素进行排序，直接在原数组上进行排序，不会新建数组 123456789101112array.sort(compareFunction())function compareFunction(a, b) { if (a &lt; b) { retrun - 1 } if (a &gt; b) { retrun 1 } return 1} reverse颠倒数组，并返回该数组，回改变原数组 1Array.reverse() 数组计算reduce和reduceRight 回调函数，函数有4个参数：前一个值，当前值，项的索引，数组对象。 该函数返回的任何值都会作为第一个参数自动传给下一项。 作为归并基础的初始值（可选） reduce1234567// 从左向右累计算var values = [1, 2, 3, 4, 5];var sum = values.reduce(function (prev, cur, index, array) {//第一次prev是1,cur是2；第二次prev是1+2=3，cur是3 return prev + cur;});alert(sum);//15 reduceRight同reduce只是从右向左进行计算","link":"/articles/2022/05/31/%E6%95%B0%E7%BB%84%E6%96%B9%E6%B3%95/"},{"title":"JS执行顺序","text":"JavaScript是一个单线程语言，是按照语句出现的顺序执行的可以将其分为同步执行和异步执行 资料链接 事件循环JavaScript执行机制，如图： 同步和异步任务分别进入不同的执行”场所”，同步的进入主线程，异步的进入Event Table并注册函数 当指定的事情完成时，Event Table会将这个函数移入Event Queue。 主线程内的任务执行完毕为空，会去Event Queue读取对应的函数，进入主线程执行。 上述过程会不断重复，也就是常说的Event Loop(事件循环)。 js引擎存在monitoring process进程，会持续不断的检查主线程执行栈是否为空，一旦为空，就会去Event Queue那里检查是否有等待被调用的函数。 代码示例： 123456789let data = [];$.ajax({ url: www.javascript.com, data: data, success: () =&gt; { console.log('发送成功!'); }})console.log('代码执行结束'); ajax进入Event Table，注册回调函数success。 执行console.log('代码执行结束')。 ajax事件完成，回调函数success进入Event Queue。 主线程从Event Queue读取回调函数success并执行。 Promise与process.nextTick(callback)Promise跳转地址 process.nextTick(callback)process.nextTick(callback)类似node.js版的”setTimeout”，在事件循环的下一次循环中调用 callback 回调函数。 除了广义的同步任务和异步任务，任务有更精细的定义： macro-task(宏任务)：包括整体代码script，setTimeout，setInterval micro-task(微任务)：Promise，process.nextTick 不同类型的任务会进入对应的Event Queue，比如setTimeout和setInterval会进入相同的Event Queue。 事件循环的顺序，决定js代码的执行顺序。 进入整体代码(宏任务)后，开始第一次循环。 接着执行所有的微任务。 然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务 123456789101112setTimeout(function () { console.log('setTimeout');})new Promise(function (resolve) { console.log('promise');}).then(function () { console.log('then');})console.log('console'); 这段代码作为宏任务，进入主线程。 先遇到setTimeout，那么将其回调函数注册后分发到宏任务Event Queue。(注册过程与上同，下文不再描述) 接下来遇到了Promise，new Promise立即执行，then函数分发到微任务Event Queue。 遇到console.log()，立即执行。 整体代码script作为第一个宏任务执行结束，发现了then在微任务Event Queue里面，执行。 第一轮事件循环结束了，开始第二轮循环，再次从宏任务Event Queue开始。发现了宏任务Event Queue中setTimeout对应的回调函数，立即执行 事件循环，宏任务，微任务的关系如图所示： 执行代码示例： 12345678910111213141516171819202122232425262728293031323334353637console.log('1');setTimeout(function () { console.log('2'); process.nextTick(function () { console.log('3'); }) new Promise(function (resolve) { console.log('4'); resolve(); }).then(function () { console.log('5') })})process.nextTick(function () { console.log('6');})new Promise(function (resolve) { console.log('7'); resolve();}).then(function () { console.log('8')})setTimeout(function () { console.log('9'); process.nextTick(function () { console.log('10'); }) new Promise(function (resolve) { console.log('11'); resolve(); }).then(function () { console.log('12') })})// 输出：1，7，6，8，2，4，3，5，9，11，10，12 根据js执行程序输出，实际会出现偏差 异步的终极解决方案async和await阮一峰ES6 async是 Generator 函数的语法糖。 await命令就是内部then命令的语法糖 async表示函数里有异步操作，返回值是 Promise 对象 await表示紧跟在后面的表达式需要等待结果，必须跟在async后面，不然会报错 用法async函数返回一个 Promise 对象，可以使用then方法添加回调函数。 当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。 123456789async function getStockPriceByName(name) { const symbol = await getStockSymbol(name); const stockPrice = await getStockPrice(symbol); return stockPrice;}getStockPriceByName('goog').then(function (result) { console.log(result);}); async的用法 12345678910111213141516171819202122232425262728293031323334// 函数声明async function foo() {}// 函数表达式const foo = async function () {};// 对象的方法let obj = { async foo() { }};obj.foo().then(...)// Class 的方法class Storage { constructor() { this.cachePromise = caches.open('avatars'); } async getAvatar(name) { const cache = await this.cachePromise; return cache.match(`/avatars/${name}.jpg`); }}const storage = new Storage();storage.getAvatar('jake').then(…);// 箭头函数const foo = async () =&gt; {}; 错误处理使用try...catch来捕获错误 123456789async function f() { try { await new Promise(function (resolve, reject) { throw new Error('出错了'); }); } catch (e) { } return await ('hello world');} 按顺序完成异步操作12345678910111213async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async url =&gt; { // 请求地址 const response = await fetch(url); return response }); // 按次序输出 for (const textPromise of textPromises) { console.log(await textPromise); }}","link":"/articles/2022/06/06/JS%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F/"},{"title":"Promise","text":"Promise 是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。 Promise对象是一个构造函数，用来生成Promise实例。 Promise promeis对象有以下两个特点： 对象的状态不受外界影响 Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。 一旦状态改变，就不会再变，任何时候都可以得到这个结果。 Promise对象的状态改变，只有两种可能：从pending变为fulfilled和从pending变为rejected。 使用方法Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject，Promise 新建后就会立即执行。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从 pending 变为 resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去； reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从 pending 变为 rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 12345678const promise = new Promise(function (resolve, reject) { // ... if (/* 异步操作成功 */) { resolve(value); } else { reject(error); }}); Promise.prototype.then()Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。 12345promise.then(function (value) { // success}, function (error) { // failure}); then方法接收两个回调函数为参数，第一个回调函数是Promise对象的状态变为resolved时调用，第二个回调函数是Promise对象的状态变为rejected时调用 Promise.prototype.catchpromise抛出一个错误，就被catch()方法指定的回调函数捕获 1234567promise .then(function (data) { //cb // success }) .catch(function (err) { // error });","link":"/articles/2022/06/06/Promise/"},{"title":"axios","text":"对axios封装，实现取消重复请求，接口错误信息展示等 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172/** * axios 封装 * @param {*} config * axiosConfig //请求配置和参数 * customOptions //自定义配置 * loadingOptions // ElLoading 效果设置 * @returns string */import axios from 'axios';import { ElLoading, ElMessage } from 'element-plus';//第三方提示组件和loading效果import { getToken } from '@/utils/auth'; // token 获取const pendingMap = new Map();//初始设置const LoadingInstance = { _target: null, _count: 0};function request (axiosConfig ,customOptions ,loadingOptions){ const service = axios.create({ // baseURL: 'http://localhost:8888', // 设置统一的请求前缀 baseURL: process.env.VUE_APP_BASE_API ? process.env.VUE_APP_BASE_API : '', // 设置统一的请求前缀 timeout: 10000, // 设置统一的超时时长 }); // 初始化自定义配置 let custom_options = Object.assign({ repeat_request_cancel: true, // 是否开启取消重复请求, 默认为 true loading: false, // 是否开启loading层效果, 默认为false reduct_data_format: true, // 是否开启简洁的数据结构响应, 默认为true error_message_show: true, // 是否开启接口错误信息展示,默认为true code_message_show: false, // 是否开启code不为0时的信息提示, 默认为false }, customOptions); // 请求拦截 service.interceptors.request.use( config=&gt;{ removePending(config); custom_options.repeat_request_cancel &amp;&amp; addPending(config); // 创建loading实例 if (custom_options.loading) { LoadingInstance._count++; if(LoadingInstance._count === 1) { LoadingInstance._target = ElLoading.service(loadingOptions); } } // 自动携带token if (getToken() &amp;&amp; typeof window !== &quot;undefined&quot;) { config.headers.Authorization = getToken(); } return config; }, error =&gt; { // 报错处理 return Promise.reject(error); } ) // 响应拦截 service.interceptors.response.use( response=&gt;{ removePending(response.config); custom_options.loading &amp;&amp; closeLoading(custom_options); // 关闭loading if(custom_options.code_message_show &amp;&amp; response.data &amp;&amp; response.data.code !== 0) { // 报错提示 ElMessage({ type: 'error', message: response.data.message }) return Promise.reject(response.data); // code不等于0, 页面具体逻辑就不执行了 } // 返回简洁数据 return custom_options.reduct_data_format ? response.data : response; }, error=&gt;{ error.config &amp;&amp; removePending(error.config); // 删除重复请求 custom_options.loading &amp;&amp; closeLoading(custom_options); // 关闭loading custom_options.error_message_show &amp;&amp; httpErrorStatusHandle(error); // 处理错误状态码 return Promise.reject(error); // 错误继续返回给到具体页面 } ) return service(axiosConfig)}export default request;/** * 处理异常 * @param {*} error */function httpErrorStatusHandle(error) { // 处理被取消的请求 if(axios.isCancel(error)) return console.error('请求的重复请求：' + error.message); let message = ''; if (error &amp;&amp; error.response) { switch(error.response.status) { case 302: message = '接口重定向了！';break; case 400: message = '参数不正确！';break; case 401: message = '您未登录，或者登录已经超时，请先登录！';break; case 403: message = '您没有权限操作！'; break; case 404: message = `请求地址出错: ${error.response.config.url}`; break; // 在正确域名下 case 408: message = '请求超时！'; break; case 409: message = '系统已存在相同数据！'; break; case 500: message = '服务器内部错误！'; break; case 501: message = '服务未实现！'; break; case 502: message = '网关错误！'; break; case 503: message = '服务不可用！'; break; case 504: message = '服务暂时无法访问，请稍后再试！'; break; case 505: message = 'HTTP版本不受支持！'; break; default: message = '异常问题，请联系管理员！'; break } } if (error.message.includes('timeout')) message = '网络请求超时！'; if (error.message.includes('Network')) message = window.navigator.onLine ? '服务端异常！' : '您断网了！'; // 报错提示根据实际进行替换 ElMessage({ type: 'error', message })}/** * 关闭Loading层实例 * @param {*} _options */function closeLoading(_options) { if(_options.loading &amp;&amp; LoadingInstance._count &gt; 0) LoadingInstance._count--; if(LoadingInstance._count === 0) { LoadingInstance._target.close(); LoadingInstance._target = null; }}/** * 储存每个请求的唯一cancel回调, 以此为标识 * @param {*} config */function addPending(config) { const pendingKey = getPendingKey(config); config.cancelToken = config.cancelToken || new axios.CancelToken((cancel) =&gt; { if (!pendingMap.has(pendingKey)) { pendingMap.set(pendingKey, cancel); } });}/** * 删除重复的请求 * @param {*} config */function removePending(config) { const pendingKey = getPendingKey(config); if (pendingMap.has(pendingKey)) { const cancelToken = pendingMap.get(pendingKey); cancelToken(pendingKey); pendingMap.delete(pendingKey); }}/** * 生成唯一的每个请求的唯一key * @param {*} config * @returns */function getPendingKey(config) { let {url, method, params, data} = config; if(typeof data === 'string') data = JSON.parse(data); // response里面返回的config.data是个字符串对象 return [url, method, JSON.stringify(params), JSON.stringify(data)].join('&amp;');}","link":"/articles/2022/06/06/axios/"},{"title":"class类","text":"JS中不存在类，class只是语法糖，本质上还是函数 面向类的设计模式：实例化，继承，多态 面向对象的设计模式：迭代器模式，观察着模式，工程模式，单列模式 组合式继承 优点：构造函数可以传参，不会和父类引用属性共享，可以复用父类的函数 缺点：子类的原型上多了不需要的父类属性，存在内存上浪费 继承父类时调用了构造函数 12345678910111213141516171819function Parent(value) { this.val = value}Parent.prototype.getValue = function () { console.log(this.val)}function Child(val) {//继承Parent的属性 Parent.call(this, val)}//继承Parent的原型Child.prototypr = new Parent()const child = new Child(1)child.getValue()child instanceof Parent // true 寄生组合继承 实现核心：将父类的原型赋值给子类，并将构造函数设置为子类 解决无用的父类属性，和正确找打子类的构造函数 123456789101112131415161718192021222324function Parent(value) { this.val = value}Parent.prototype.getValue = function () { console.log(this.val)}function Child(val) {//继承Parent的属性 Parent.call(this, val)}Child.prototype = Object.create(Parent.prototype, { constructor: { value: Child, enumerable: false, writable: true, configurable: true }})const child = new Child(1)child.getValue()child instanceof Parent // true class继承 定义一个子类之后，相对于父类来说它就是一个独立并完全不同的类 子类包含父类行为的原始副本，单也可以重写所有继承行为甚至定义新行为 class实现继承的核心是extends表明继承来着那个，并且在子类的构造函数中必须调用super 123456789101112131415161718192021class Parent { constructor(value) { this.val = value } getValue = function () { console.log(this.val) }}class Child extends Parent { constructor(value) { super(value) this.val = value }}let child = new Child(1)child.getValue()child instanceof Parent // true","link":"/articles/2022/05/31/class%E7%B1%BB/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"JS基础","slug":"JS基础","link":"/tags/JS%E5%9F%BA%E7%A1%80/"},{"name":"JavaScript介绍","slug":"JavaScript介绍","link":"/tags/JavaScript%E4%BB%8B%E7%BB%8D/"},{"name":"工具","slug":"工具","link":"/tags/%E5%B7%A5%E5%85%B7/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"ES6","slug":"ES6","link":"/tags/ES6/"},{"name":"axios","slug":"axios","link":"/tags/axios/"}],"categories":[{"name":"JavaScript","slug":"JavaScript","link":"/categories/JavaScript/"},{"name":"基础","slug":"JavaScript/基础","link":"/categories/JavaScript/%E5%9F%BA%E7%A1%80/"},{"name":"工具","slug":"工具","link":"/categories/%E5%B7%A5%E5%85%B7/"},{"name":"ES6","slug":"JavaScript/ES6","link":"/categories/JavaScript/ES6/"},{"name":"git","slug":"工具/git","link":"/categories/%E5%B7%A5%E5%85%B7/git/"},{"name":"axios","slug":"工具/axios","link":"/categories/%E5%B7%A5%E5%85%B7/axios/"}]}